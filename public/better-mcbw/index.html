<!DOCTYPE html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=description content="Musings about UX, product design, user research, dance, ultimate, curling, and beer pancakes."><meta name=author content="Brad Orego"><base target=_blank><title>Better MCBW</title><link href=/index.xml rel=alternate type=application/rss+xml title=bradorego.com><link href=/index.xml rel=feed type=application/rss+xml title=bradorego.com><link href=/css/all.css rel=stylesheet><link href=https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css rel=stylesheet></head><body><div id=scrollUp class="floating-button ion-arrow-up-b ion-24 hidden"></div><nav class="navbar fixed-top navbar-dark bg-dark"><div class=container><a class=navbar-brand href="/" target=_self><h1>Bradley Orego</h1><h2>Product Designer. Usability Researcher. Entrepreneur. Dancer.</h2></a><div class="btn-group d-flex" role=group><a role=button href="/" target=_self class="btn btn-outline-light w-100">Showcase</a> <a role=button href=/blog target=_self class="btn btn-outline-light w-100 active">Blog</a> <a role=button href=/about target=_self class="btn btn-outline-light w-100">About</a></div></div></nav><div class="blog-body container"><div class=blog-header><div class=bg-image style="background-image: url('http://bradorego.com//img/showcase/better-mcbw/header.jpg')"></div><div class=text><h1>Better MCBW</h1><hr class=small><h3 class=subheading>How I reverse engineered a beer app and reached feature parity in ~8 hours with Ionic.</h3><h5>11 minute read</h5></div></div><div class=blog-content><div class=tldnr><h4>TL;DNR</h4><ul><li><a href=http://ionicframework.com>Ionic</a> lets you build apps ridiculously fast. Write once, build many.</li><li>If you don't like how something's done, instead of just complaining about it, do something to make it better.</li><li>Reverse engineering is easier than ever. Your success is not a factor of your codebase, but about the value you offer an end-user.</li><li>The end result: <a href=http://mcbw.herokuapp.com>Better MCBW</a></li></ul></div><hr><h1 id=backstory-a-name-backstory-href-backstory-i-class-ion-link-i-a>Backstory <a name=backstory href=#backstory><i class=ion-link></i></a></h1><p><a href=http://madbeerweek.com>Madison Craft Beer Week</a> has been one of my favorite events since moving to Madison. Started as a grassroots project by a few local beer lovers, the event has ballooned to one of the best in the nation, featuring over 550 events this year. In years past, I&rsquo;ve been involved in helping out on the tech side of things, and we had big plans for this upcoming year. But in September 2015, The Isthmus <a href="http://isthmus.com/food-drink/beer/isthmus-acquires-madison-craft-beer-week/">acquired Craft Beer Week</a>, and took over all operations.</p><p>After hearing that the 2016 was <a href=https://www.facebook.com/MadBeerWeek/posts/1225581240785685>built natively</a>, and as an Android user I would have to wait to get my hands on it, questions arose as to why such a technically/mechanically simple app wasn&rsquo;t built using <a href=http://ionicframework.com>Ionic</a>, a mobile app development framework built by a company based in Madison. After I got my hands on the Android app itself, I was less than enthusiastic about its performance and feature set.</p><h1 id=reverse-engineering-it-a-name-reverse-href-reverse-i-class-ion-link-i-a>Reverse Engineering It <a name=reverse href=#reverse><i class=ion-link></i></a></h1><p>So, realizing that my complaints weren&rsquo;t getting anyone anywhere (not to mention I lacked the necessary context to know why they made the decisions they made), I had an idea: I have the APK, so I can decompile it, dig through it, and figure out exactly what API calls they&rsquo;re making, and then emulate them with my own codebase. Simple enough, right? Well, for someone that knows virtually nothing about native Android development, this task proved simple yet pointless. I only gained one insight from it, which was the URL of their API. Then another idea hit me: why not just set up a proxy and read the HTTP requests?</p><h3 id=enter-mitmproxy>Enter <code>mitmproxy</code></h3><p>After doing a little bit of googling, I came across this <a href=https://medium.com/@rotxed/how-to-debug-http-s-traffic-on-android-7fbe5d2a34#.mhbido9ys>incredibly helpful article</a> explaining step-by-step exactly what I wanted to do. Next thing I know, I had a proxy running on my laptop, my phone&rsquo;s internet traffic streaming through that proxy, and I had access to every HTTP request the phone (and thus, the app) made. It was almost too easy.</p><p><img src=/img/showcase/better-mcbw/mitmproxy.png></p><h3 id=the-horror>The Horror</h3><p>So, now that I had all of the HTTP requests (all, uh, 4 of them that the app seemed to be making), all I had to do was make those same requests with the same body, parse the response, and I was off to the races, right? This is all true, but in my inspection of the traffic, I came across a few horrifying realizations:</p><ol><li>Every request made was a <code>POST</code>. Getting the list of events? <code>POST</code>. Creating an account? <code>POST</code>. Logging in, and creating a session? <code>POST</code>. Getting a list of special offers? <code>POST</code>.</li><li>Every response had a status of <code>200 - OK</code>. If there was an error, you have to parse the body of the message. And those bodies are in no way consistent.</li><li>The list of events (~580 json objects) came out to a staggering 700KB of data. Not the end of the world in today&rsquo;s day and age, but a tough pill to swallow. There&rsquo;s gotta be something we can do about that, right? (Spoiler alert: there is).</li></ol><p>Interacting with this API was painful. I was literally parsing a tilde(~) delimited string to determine the result of actions, and then picking parts of that out to save (e.g. the access token). This kind of feels like somebody&rsquo;s first attempt at making an API.</p><h3 id=off-to-the-races>Off to the Races</h3><p>All of that aside, I thought I was in the clear. Build an Ionic app, replicate the responses, do some other stuff with the data. Simple enough, right? Aaaaand then I got <code>CORS</code>&rsquo;d, which I should&rsquo;ve seen coming. After trying to find a way to get Angular to work around pre-flighting requests, I decided to bite the bullet and build a node proxy. ~100 lines of <code>Node.js</code>/<code>Express</code> code later, I was in business. Now we can send our requests to our own server which would make the same requests to the Craft Beer Week API and pass the results back.</p><pre><code class=language-javascript>app.post('*', function (req, res, next) {
  console.log(&quot;requesting &quot; + API_URL + req.originalUrl);
  request.post(API_URL + req.originalUrl, {form: req.body},
    function (error, response, body) {
      if (body.indexOf('Your session') !== -1) {
        res.status(401);
        return res.send(body);
      }
      console.log(response.statusCode + &quot; - &quot; + response.statusMessage);
      res.status(response.statusCode);
      res.send(body);
    });
});
</code></pre><h3 id=feature-parity>Feature Parity</h3><p>With all of that behind us, all we needed was to do was create the Ionic app to do what the native app did. Considering the native app is just a list of events, that was pretty straightforward. As part of this process, I&rsquo;d spun up a little <a href=http://firebase.com>Firebase database</a> to save my own version of user accounts (which I was still creating via the MCBW API). Further inspection of the app&rsquo;s &ldquo;save&rdquo; feature revealed a lack of persistence of those events (it was only saving it on the device), so in trying to replicate features I was actually already improving the experience.</p><p>The rest, as they say, is history (or, at least, trivial).</p><h3 id=deploying-to-heroku>Deploying to Heroku</h3><p>Having a feature-parity Ionic app on your local machine is great and all, but it doesn&rsquo;t do much good. Enter <a href="http://blog.ionic.io/heroku-ionic/">Ionic Heroku</a>, which is a nifty little boilerplate that takes care of all of the setup and deploy configuration Heroku needs. You can hit one button, punch in a name, and you have a Heroku app. Copy your www/ file into the boilerplate&rsquo;s (and update any npm/bower/ionic config you need to) and you&rsquo;re golden. This was possibly the easiest step in the process.</p><h1 id=making-it-better-a-name-improve-href-improve-i-class-ion-link-i-a>Making It Better <a name=improve href=#improve><i class=ion-link></i></a></h1><p>At this point, I&rsquo;d spent about 8 hours including all development time and research into how their API worked. I could&rsquo;ve called it a day - I&rsquo;d built an app that reached feature parity and could be deployed to Android and iOS. My work here was done. But, even by reaching parity, I hadn&rsquo;t made anything better. At the end of the day, I was building this app for myself, so stopping here wouldn&rsquo;t&rsquo;ve helped. So, I set out with a short list of ways to improve the experience:</p><ul><li>700KB of JSON seemed like a bit much</li><li>Date dividers would make scanning the list a lot easier</li><li>Saving a list of events is one thing, being able to share that list is another</li><li>Different ways of sorting (e.g. by location name, by event name)</li><li>A map view would be clutch</li><li>What if I got an email every morning with my saved events for the day?</li></ul><h3 id=gzip-is-your-friend><code>gzip</code> is your friend</h3><p>Where do we start? What&rsquo;re the low-hanging fruit? Let&rsquo;s see what we can do about this JSON dump. As it turns out, the MCBW API wasn&rsquo;t using any compression. Enabling <code>gzip</code> on my Node server brought that 700 down to ~100, which is a huge improvement. Inspecting the data further, it seemed that all the data was there twice - as both an index and a keyed index. That lead to a horrific piece of code that looked something like this:</p><pre><code class=language-javascript>  delete jsonBody[i][0];
  delete jsonBody[i][1];
  delete jsonBody[i][2];
  delete jsonBody[i][3];
  delete jsonBody[i][4];
  delete jsonBody[i][5];
  delete jsonBody[i][6];
  delete jsonBody[i][7];
  delete jsonBody[i][8];
  delete jsonBody[i][9];
  delete jsonBody[i][10];
  delete jsonBody[i][11];
  delete jsonBody[i][12];
</code></pre><p>Which brought us down to 80KB. Still not great, but much better than 700KB. Okay, great, what&rsquo;s next? Sharing seems like it&rsquo;s pretty straightforward.</p><h3 id=enabling-sharing>Enabling sharing</h3><p>This isn&rsquo;t going to be a lecture about how powerful social sharing plugins are in viral/organic growth. I&rsquo;m less concerned about that and more concerned about the end-user experience. Considering I already had my own Firebase database, enabling this was actually trivial. Create a route outside the context of the app (otherwise users would get redirected to login) that took in the user&rsquo;s ID (from the URL) and pulled out the list of their saved events. Simple, straightforward, elegant. Add in a few social share buttons for convenience and the app practically markets itself.</p><p><img src=/img/showcase/better-mcbw/sharing.png></p><h3 id=dividers>Dividers</h3><p>Regardless of the content, a 500-item list is overwhelming. Adding date dividers at least makes it a little easier to scan through. The implementation of this is actually pretty straightforward. Here&rsquo;s that snippet (for dates) in all its glory:</p><pre><code class=language-javascript>  for (i = 0; i &lt; events.length; i++) {
    if (events[i].type !== &quot;divider&quot;) { /// don't process dividers if we come across them
      tempDate = new Date(events[i].start_date);
      if (currentDate.getDate() !== tempDate.getDate()) { /// tempDate is a new date!
        currentDate = tempDate;
        events.splice(i, 0, {type: &quot;divider&quot;, value: dayDividerFormat(currentDate)});
        i--; /// backtrack so we don't miss something
      }
    }
  }
</code></pre><p>Couple this with <code>$ionInfiniteScroll</code> and we have lazy-loading events 20 at a time plus dividers. Much better than spitting out a list of 500 events and having users fend for themselves.</p><h3 id=searching-sorting-maps>Searching, Sorting, Maps</h3><p><img src=/img/showcase/better-mcbw/map.png></p><p>That&rsquo;s great and all, but what if I&rsquo;m looking for a specific event? What if I&rsquo;m in a particular part of town and I want to know what my other options are nearby? Sorting and Filtering were actually somewhat of a happy accident between what Angular offers and how I&rsquo;d structured the rest of the app. When the user logs in, I fetch the list of events once and cache it. From there, pretty much everything they see is some permutation of that.</p><p>It&rsquo;s a fair amount of heavy-lifting on the client, but it also means I have all the source material and we&rsquo;re minimizing the number of round-trips. I already have a mechanism for adding dividers, so if I want to enable other sorting (the Node server sorts by start date by default), all I needed to do was a simple Javascript <code>Array.sort()</code> and then pass that into the divider function.</p><p>Searching proved a little more complicated. Aforementioned lazy loading meant I couldn&rsquo;t just use an Angular <code>$filter</code> (without additional complications - I&rsquo;m sure I could&rsquo;ve), but that local cache made it fairly trivial. Here, <code>Array.filter()</code> came to the rescue. A simple string compare (via the ever-popular <code>String.indexOf()</code>) spat out the results we crave.</p><p>Mapping proved a little more difficult. After wrestling with all of the available Angular Google Maps solutions, I settled on <a href="https://ngmap.github.io/">ngMap</a>. It made the most sense to me from a structural standpoint, and made a lot of the subsequent code incredibly easy to write (think: virtually no controller code to place markers and pop up and info window on click). A little date finagling to make sure we&rsquo;re showing the right pins, and a tiny insight into managing 500 events on a map (which is actually something I learned from last year&rsquo;s MCBW website) and we&rsquo;ve finally reached a point where I think I can say I&rsquo;m done. Well, almost&hellip;.</p><h3 id=checkin-da-emails>Checkin&rsquo; da Emails</h3><p>This is a terrible example of staying lean (as opposed to most of the other development on this project, which was driven by me trying to use my own app out in the wild), but I had the idea of sending an email every morning with the list of events you&rsquo;d saved for that day. Partly because, theoretically, that eliminates the need to ever check your to-do list again. Log on once, save the events you want, and then it&rsquo;ll email you your schedule for the day. Sounds ideal.</p><p>After wrestling with MailGun for awhile, <a href="https://sendgrid.com/">SendGrid</a> won out in terms of simplicity. I had test emails out within minutes, and all I had to do then was write a little server code to compile the list, do some basic HTML formatting, and that&rsquo;s one more feature to add to the list. I thought I was just doing this for myself, but I was instantly validated by this exchange:</p><p><img src=/img/showcase/better-mcbw/lauren.png></p><h1 id=the-fuuuuuuuuuture-a-name-future-href-future-i-class-ion-link-i-a>The Fuuuuuuuuuture <a name=future href=#future><i class=ion-link></i></a></h1><p>More than once already this week, people have brought up the idea of some sort of optimization algorithm. Each event has a start time, and end time, and a location. This sounds like some sort of modified Travelling Salesman Problem, and while that would be a lot of fun to try to implement, I think that&rsquo;s a &ldquo;next-year&rdquo; type of feature. After all, I&rsquo;ve already sunk a whopping ~20 hours into this project. I can only imagine what The Isthmus paid their developers and how much time they spent on this.</p><p>The code could also use a serious refactor, especially on the client side. This is what happens when innovation/speed of development matters more than code quality/longevity/cost of support. Whoops.</p><p>There also could be increased security, as right now I&rsquo;m pretty sure if you have someone&rsquo;s user ID you can modify their list of saved events, but again, 20 hours of free work plus it&rsquo;s an app that&rsquo;s only useful for one week (and for a beer event, no less).</p><h1 id=lessons-learned-a-name-lessons-href-lessons-i-class-ion-link-i-a>Lessons Learned <a name=lessons href=#lessons><i class=ion-link></i></a></h1><h3 id=firebase-synchronized-arrays>Firebase Synchronized Arrays</h3><p>One thing I learned in trying to build this Saved Event feature is <a href=https://www.firebase.com/docs/web/libraries/angular/guide/synchronized-arrays.html>Firebase arrays</a> don&rsquo;t work the way you think they do. I had a list of events (JSON objects) that I would push to an array (via <code>$firebaseArray.$add</code>), and when someone unchecked the magic box, I tried to use <code>$firebaseArray.$remove</code>, except that only works if you&rsquo;re talking about the same reference you used to push to the array. So, if you have a list of items, you push <em>a copy</em> of one to the array, then try to remove it, it didn&rsquo;t work.</p><h3 id=keyed-arrays-make-sense-sometimes>Keyed Arrays Make Sense Sometimes</h3><p>As a corollary to the above realization, keyed arrays actually make a lot of sense sometimes. The solution to this problem (while not the most elegant/efficient solution) is to create a keyed array of saved events. Every time a user saves/unsaves an event, we update the user&rsquo;s <code>saved</code> array by updating the object at that key, e.g.</p><pre><code class=language-javascript>  profile.saved[event.id] = event;
  /// or
  delete profile.saved[event.id];
</code></pre><h1 id=videos-a-name-videos-href-videos-i-class-ion-link-i-a>Videos <a name=videos href=#videos><i class=ion-link></i></a></h1><h3 id=official-mcbw>Official MCBW:</h3><iframe width=100% height=315 src=https://www.youtube.com/embed/s4OAGhlFpcQ frameborder=0 allowfullscreen></iframe><h3 id=better-mcbw>Better MCBW:</h3><iframe width=100% height=315 src=https://www.youtube.com/embed/yAJx1i41d04 frameborder=0 allowfullscreen></iframe><hr><p class=post-meta>Posted on May 2, 2016 in <a href=/categories/development target=_self>Development</a><br>Tags: <a href=/tags/ionic target=_self>[ionic]</a> <a href=/tags/madbeerweek target=_self>[madbeerweek]</a> <a href=/tags/reverse-engineer target=_self>[reverse engineer]</a> <a href=/tags/ux target=_self>[ux]</a> <a href=/tags/feature-parity target=_self>[feature parity]</a> <a href=/tags/firebase target=_self>[firebase]</a></p><hr>All <b>Development</b> posts:<p></p><ul class=categories><li><a href="http://bradorego.com/better-mcbw/" target=_self>Better MCBW</a></li><li><a href="http://bradorego.com/back-to-static/" target=_self>Back to Static</a></li><li><a href="http://bradorego.com/progressive-enhancement-with-phonegap/" target=_self>Progressive Enhancement with Phonegap</a></li><li><a href="http://bradorego.com/foursquare-heatmap--remote-sensing/" target=_self>Foursquare Heatmap &amp; Remote Sensing</a></li><li><a href="http://bradorego.com/new-site/" target=_self>New Site!</a></li></ul></div></div><footer><div class=container><hr class="medium dark"><ul class="list-inline text-center"><li class=list-inline-item><a href=mailto:hello@bradorego.com><i class="ion-android-mail ion-32"></i></a></li><li class=list-inline-item><a href=https://twitter.com/bradorego><i class="ion-social-twitter ion-32"></i></a></li><li class=list-inline-item><a href=https://github.com/bradorego><i class="ion-social-github ion-32"></i></a></li><li class=list-inline-item><a href=https://instagram.com/bradorego><i class="ion-social-instagram ion-32"></i></a></li><li class=list-inline-item><a href=https://linkedin.com/in/bradorego><i class="ion-social-linkedin ion-32"></i></a></li><li class="patreon list-inline-item"><a href=https://www.patreon.com/bradorego><svg version=1.0 xmlns=http://www.w3.org/2000/svg width=24pt height=18pt viewbox="0 0 160 166"><g transform="translate(0,160) scale(0.1,-0.1)" fill=#404040 stroke=none><path d="M0 800 l0 -800 145 0 145 0 0 800 0 800 -145 0 -145 0 0 -800z"></path><path d="M911 1580 c-204 -54 -374 -225 -427 -431 -22 -84 -22 -227 1 -304 48 -168 167 -312 317 -384 105 -50 182 -65 301 -58 116 7 198 35 296 101 165 113 261 294 261 491 -1 398 -367 685 -749 585z"></path></g></svg></a></li></ul><div class=text-center><a href=http://rochestermade.com title="Rochester Made"><img alt="Rochester Made" id=rochesterMade src=http://rochestermade.com/media/images/rochester-made-dark-on-light.png title="Rochester Made"></a></div></div></footer><script src=/js/all.js></script></body></html>